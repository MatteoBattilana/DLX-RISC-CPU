\chapter{Memory Stage}
\label{chp:memory_stage}
The memory stage allows to perform operations with the memory, the DRAM in this case, in order to load or store a value from/to the memory respectively. Figure \ref{fig:mem_stage} shows the Memory Stage of the DLX pipeline.

\begin{figure}[H]   
    \centering
    \includegraphics[width=0.85\textwidth]{chapters/6_MemoryStage/images/mem_stage.pdf}
    \caption{Memory stage}
    \label{fig:mem_stage}
\end{figure}

If the instruction that reaches the memory stage is a load, the value stored into the \texttt{REG\_ALU\_OUT} register is fed to a block that performs the masking of the address itself. Then the masked address is given as input to the external memory in order to retrieve the data. A multiplexer with two inputs allows to select the data coming from the memory and redirects it to another unit, called \texttt{datamem\_ldstr} that uses the \texttt{DATA\_SIZE} and \texttt{UNSIG\_SIGN\_N} inputs to select the correct bits for word, half-word and byte.

In the case of a store, the address in which the data must be saved into the memory is masked too via the Address Mask Unit and its output is given to the DRAM. The data stored in the \texttt{REG\_ME} register is selected, by correctly configuring the multiplex to choose it, and put as input to the \texttt{datamem\_ldstr} unit. The output of this unit is put as input data to the DRAM, that performs the store.

\section{Address Mask Unit}
The basic idea behind the Address Mask Unit is to modify the address, given as input, depending on the data size to store or load. All the possibility and masking procedures are summed up in Table \ref{tab:addr_masking}. 

\begin{table}[ht]
    \begin{center}
        \begin{tabular}{ c| l | l}
            \texttt{DATA\_SIZE} & \textbf{Dimension} & \textbf{Masking}\\
            \hline
            00 & word & \texttt{ADDR\_IN(ADDR\_IN'length-1 downto 2) \& "00"}\\
            01 & half word & \texttt{ADDR\_IN(ADDR\_IN'length-1 downto 1) \& "0"} \\
            10 & byte & \texttt{ADDR\_IN}
            
        \end{tabular}
        \caption{Address masking for all the three possible cases}
        \label{tab:addr_masking}
    \end{center}
\end{table}


Give an address, it must be correctly aligned depending on the dimension of the data the processor want to write/read to/from memory. Refer to the \ref{vhdl_masking_addr} VHDL snippet. The problem with the alignment arises when data to be accessed are larger than the addressable unit (word vs byte). \\

After the generation of the correct address, is a DRAM duty to output the data in the proper byte lanes, as explained in Table \ref{table:memory_read_configuration}. The operation of reading from the correct byte lane and apply a sign extension (if requested) is made by the \ref{sec:ldstr} \emph{Load-Store Unit}.

% This allows to read always 32 bits from the memory from the correct position, thanks to the masking process. Since the data is on 32 bits, we need to select 8, 16 or 32 bits from it accordingly to the \texttt{DATA\_SIZE} two bits signal. This is done in the Load-Store Unit.


\hfill
\begin{lstlisting}[style=vhdl,caption={VHDL code for address alignment},label=vhdl_masking_addr]
    with DATA_SIZE select
        ADDR_OUT <= ADDR_IN(ADDR_IN`length-1 downto 2) & "00" when "00",
        ADDR_IN(ADDR_IN`length-1 downto 1) & "0"  when "01",
        ADDR_IN when others;
\end{lstlisting}

\section{Load-Store Unit}
\label{sec:ldstr}
The Load-Store Unit is used to perform the following operations:
\begin{itemize}
    \item Extract the correct bits from the data coming from the memory, using the address generated by the Address Mask Unit. Depending of the \texttt{DATA\_SIZE} and the \texttt{ALOW} signals, the data is selected.
    
    When the address has been correctly masked to fetch a word (32 bits), the data doesn't need to be extracted, nor the sign extension is needed. In the other two cases, when managing half-word or byte, the correct portion of bits must be taken. 

    \item If the unit is managing half-word or byte, the bits can be simply taken and set as the output of the Load-Store Unit only if working with unsigned. In this case, all the others bits are set to 0. On the other hand, if the byte or the half-word granularity is used and the \texttt{UNSIG\_SIGN\_N} is set to `0', a sign extension must be performed. In this case, the correct portion of bits is taken, as defined in Table \ref{tab:addr_selection}, and the first bit of it used extends the sign.

    \item Data Replication in case of a Store to memory. Refer to Figure \ref{figure:dlx:memory_replication}.  


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ |c| c | l | l|}
                \hline
                \texttt{DATA\_SIZE[1:0]} & \texttt{ALOW[1:0]} & \textbf{Type} & \textbf{Selected bits}\\
                \hline
                00 & \texttt{--} & word & [31-0]\\
                01 & \texttt{0-} & half A & [31-16]\\
                01 & \texttt{1-} & half A+2 & [15-0]\\
                10 & \texttt{11} & byte A+3 & [7-0]\\
                10 & \texttt{10} & byte A+2 & [15-8]\\
                10 & \texttt{01} & byte A+1 & [23-16]\\
                10 & \texttt{00} & byte A & [31-24]\\
                \hline
                
            \end{tabular}
            \caption{Bits selection using \texttt{DATA\_SIZE} and \texttt{ALOW}}
            \label{tab:addr_selection}
        \end{center}
    \end{table}

    
\end{itemize}
A more detailed explanation of the memory interface is available in section \ref{mas}.