\chapter{Decode Stage}

\section{Instruction Decode}
\section{Register File and Windowing}
The general structure of a register file is based on a decoder that takes the selection input (so the address of the desired register) and enables it (using also the enable signal). At this point, an input signal will contain the value to be written. On the other hand, a read signal is used to select among all the registers.\newline\newline
The DLX presented in this document has been enhanced in order to be able to manage subroutine in a transparent manner from the point of view of the user. For this reason, the DLX must be able to handle subroutines, and so the context switching, that consists in saving the
registers content in order to be restored once the procedure has been completed. The straightforward solution is to save into the memory all registers but this is not feasible in terms of delay, since for 32 registers we will need 32 clock cycles; if you image this in a pipeline, this corresponds to a long stall each time a procedure is called.

A windowed register allows to reduce the overhead due to the context switch; the basic idea
is to split the available registers in the physical register file into blocks, called \textit{windows}. We have limited amount of physical registers in the register file, for this reason a finite number of windows are defined. Each window is assigned to a subroutine, so that the procedure can write only on those register. This is transparent from the point of view of the CPU, that sees all registers available. Thus, the physical register file has a wrapper around it with a logic and a Register Management Logic (MML) that allows to perform the translation between the CPU requests to corresponding window for the running procedure.\newline\newline
What if the number of called procedure is larger than the number of available windows? The main
memory is involved only when there are no free windows in the register file. In this case, the oldest allocated window is swapped into the main memory, so that the new one can be allocated. Obviously, once all the recursion chain has been unrolled, the swapped window in the memory must be restored into the register file.
All windows, so each procedure, has 4 blocks of 8 registers each one:
\begin{enumerate}
	\itemsep0sp
	\item \textbf{IN}: the first block is dedicated to the data inherited from the parent routine (OUT);
	\item \textbf{LOCALS}: contains the registers that are dedicated to the procedure;
	\item \textbf{OUT}: is dedicated to the variables to be passed to the child routine, that is the IN of the next sub-procedure
	\item \textbf{GLOBAL}: the last block is common to every windows.
\end{enumerate}
When a procedure is called, the first LOCALS and OUT blocks are allocated from the physical file register and assigned to it (because IN is the OUT of the previous one).

By calling many nested procedures, at some point there will be no free windows; for this reason the oldest is de-allocated from the physical FR and swapped to the main memory, the operation is called \textbf{SPILL}. This it accomplished by using a support pointer, called \textbf{Saved Window Pointer SWP} that stores the point of the spilled data, exactly the end of the LOCALS block (only IN and LOCAL are spilled, the OUT block is not spilled because is the IN of the next sub-procedure). In practice it define the position of the last free cell. Notice that this operation cannot be executed in one clock cycle: each register is spilled once at a clock cycle.\newline\newline
On the other hand, when the last procedure in the chain is finished, the other are unrolled; if some of them have been spilled, a \textbf{FILL} must be executed before the actual execution. This can be achieved by, firstly decrement CWP by 16 and check if now CWP $>>$ SWP.\newline\newline
It's important to notice that the implementation of the entire register file has been implemented in Structural. Is is composed by several components:
\begin{itemize}
	\item \textbf{Decoder}: it is used to generate a single enable signal from a signal on \textbf{NBIT\_ADD} bits; in this way, a register is selected in order to perform a write. The register will check also if a write is requested;
	\item \textbf{Connection matrix}: this block allows to ``highlight" the active windows, the block IN, LOCAL and OUT will be the default destination when writing and reading;
	\item \textbf{Register file}: this block corresponds to the physical registers, composed by rows of Flip-Flops;
	\item \textbf{Select block}: this block is used for the reading, is connected to all the registers and selects, using the read address, the single register to be read;
	\item \textbf{Address generator}: this block is used only when perform a FILL or a SPILL, it generates the address for the registers to be moved from/to the memory. The memory, in this case works exactly like a stack.
\end{itemize}
Additional, but less complex components, have been used in order to manage the management of the CWP and SWP.


\subsection{Decoder}
This block receives as input the \emph{write address} on \textbf{NBIT\_ADD} bits and outputs \(\mathbf{2^{NBIT\_ADD} - 1} \) bits. It has the utility of converting the address of the register at which we need to write into its enable signal. 

The idea is that if the input is \(0b00010\) the output will be \(0b00000000000000000000000000000100\). In fact if the input is decimal 2, it means that we need to write the second register of the \emph{GLOBAL} block. In terms of enable it can be translated by having the bit with index 2 at one. In fact in the output we see that the it with index 2 has value 1, while the others are all 0. 

The output is divided (in the schematic) in order to represent the group of bits. In particular we have that: 
\begin{itemize}
    \item M - 1 DOWNTO 0: bits associated to the \emph{GLOBAL} register
    \item M + N - 1 DOWNTO M: bits associated to the \emph{IN} register
    \item M + 2N - 1 DOWNTO M + N: bits associated to the \emph{LOCAL} register
    \item M + 3N - 1 DOWNTO M + 2N: bits associated to the \emph{OUT} register
\end{itemize}

On the top of the schematic (\autoref{decoder}) we can see an AND logic port between \emph{ENABLE} and \emph{WR} signals. If both \emph{ENABLE} and \emph{WR} are 1, it means that our register need to work. In fact, the output of the dedocer is anded with 1 and so we maintain the value. Otherwise, if one signal between \emph{ENABLE} and \emph{WR} is 0, the output will be 0 and so the AND with the output of the \emph{decoder} will return all 0. 

This signal goes into the \emph{connection matrix}, which is the next block described. 

%% MAKE FONT BIGGER
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth]{chapters/4_DecodeStage/images/Decoder.pdf}
    \caption{Schematic of the Decoder}
    \label{decoder}
\end{figure}
%% MAKE FONT BIGGER

\subsection{Connection Matrix}

With the previous block, we generated all our enable signals. The problem is that we have more windows. So how do we decide which window needs to be activated? Here comes the connection matrix. This block receives as inputs the signal coming from the decoder, the current window, the saved window and the address for the pop (fill) operation. The output is a signal that contains the enable signals ready for all the registers of all windows. 

We have a specific structure for each block:
\begin{itemize}
  \item GLOBAL: the global is the simplest, because it is connected directly to the output
  \item IN: for this block we AND the IN bits coming from the decoder with the bit (that is extended) of the related window. For example if we are evaluating the IN of the first window, we will AND the IN bits with the bit 0 of the current window.
  \item OUT: for this block we AND the OUT bits coming from the decoder with the bit (that is extended) of the previous related window. For example if we are evaluating the OUT of the first window, we will AND the OUT bits with the bit 4 of the current window (supposing our window has 5 bits).
  \item LOCAL: for this block we AND the LOCAL bits coming from the decoder with the bit (that is extended) of the related window. For example if we are evaluating the LOCAL of the first window, we will AND the LOCAL bits with the bit 0 of the current window.
\end{itemize}

For the IN and OUT we then an OR between the two outputs (the logic can be seen in the schematic), while for the LOCAL we don't have anything.

In addition to that, the connection matrix also manages the saved window, used for the pop (fill) operation. First we need to invert the addr\_pop, because when we execute the pop operation, we restore data starting from the last one (we are using a STACK).
The addr\_pop\_inverted is composed like this:
\begin{itemize}
  \item 2N - 1 DOWNTO 0: we have the IN bits 
  \item N - 1 DOWNTO 0: we have the LOCAL bits
\end{itemize}

The signal is splitted into two wires and is anded with the saved related saved window pointer. 

In the end, we definitely OR the output of the previously described OR with the output of this AND. This is visible in \autoref{connection_matrix}

\begin{figure}[ht]
  \centering
  \addtolength{\leftskip}{-3cm}
  \addtolength{\rightskip}{-3cm}
  \includegraphics[width=1.4\textwidth]{chapters/4_DecodeStage/images/connection_matrix.pdf}
  \caption{Connection matrix}
  \label{connection_matrix}
\end{figure}

\newpage

\subsection{Register File}

The next block is the Register File, that is a sequence of registers. The important thing to notice in our design is how we managed the data that goes into the registers. We have two choices, data\_in and from\_mem. In order to choose we decided to use multiplexers. 
We have a multiplexer for each window. The signal used to drive the multiplexer is the saved window pointer, rotated right by 1 position and anded with the pop signal. In fact, we select from\_mem only when the pop signal is 1, otherwise we need to select data\_in. 
We use the saved window pointer shifted right by 1 because when the saved window pointer is, for example 00010 we need to restore the window 00001. 

Indeed, for dataout there are no multiplexers, because there is no choice. 

\subsection{Select Block}

This block is very simple and straightforward. It receives as input the current window, and the output of the register file (of all windows). The it selects the bit of the IN, LOCAL, OUT of the current window. The interface is shown in \autoref{select_block}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.65\textwidth]{chapters/4_DecodeStage/images/select_block.pdf}
  \caption{Interface of the select block}
  \label{select_block}
\end{figure}

\subsection{Output Selection}
This is the stage that decide the two output Data1\_Out and Data2\_Out. The design is shown in \autoref{output_choice}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{chapters/4_DecodeStage/images/output_choice.pdf}
  \caption{Design of the output selection}
  \label{output_choice}
\end{figure}

This stage receives the IN, LOCAL, OUT of the current window, thanks to the select block and the GLOBAL. The two addresses, ADD\_RD1 and ADD\_RD2, select the output of the multiplexer which goes into the register, used to respect the timing. The Enable of each register is the and of the ENABLE and the RD signal. The decision was made in order to stop reading when the circuit is not enabled, and so to have a granural and precise control of the circuit.

\subsection{Next Window Calculator}

This block is used to compute the next window, both for the current window and the saved window. The schematic is shown in \autoref{nwin_cal}.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{chapters/4_DecodeStage/images/nwin_cal.pdf}
  \caption{Design of the next window calculator}
  \label{nwin_cal}
\end{figure}

Inside this block there is a logic able to rotate right or left and a multiplexer, that allows to select the correct output based on what the circuit needs. 

\section{Hazard Control}
\section{Comparator}
The straightforward way to implement a comparator, allows only to check if two operands, \texttt{A} and \texttt{B}, are equals. The solution is sketched at figure \ref{fig:comparator_basic}, that is based on $N$ XNOR, where $N$ is the number of bits of the operands and an AND gate with $N$ inputs.

Even if this solution is extremely compact, it allows to perform only the equality comparison; since this DLX implementation has the ability to perform complex conditional branch instructions (refer to the Instruction section \ref{section:inst_set}) and conditional set instructions (refer to the Set-Like Operations Unit \ref{section:set_link_operations_unit}) we need a more complex solution. In fact, if we need to perform a jump only if \texttt{A} $>$ \texttt{B} (strictly greater) we need to check exactly this precise condition.

\begin{figure}[H]
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=0.55\textwidth]{chapters/4_DecodeStage/images/comparator_basic.pdf}
		\caption{Design of the basic comparator}
		\label{fig:comparator_basic}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=0.7\textwidth]{chapters/4_DecodeStage/images/comparator_advanced.pdf}
		\caption{Design of the advanced comparator}
		\label{comparator_advanced}
	\end{minipage}
\end{figure}

The advance comparator exploits the comparison by performing a subtraction between \texttt{A} and \texttt{B} and then checking the result. This DLX implementation is based on a P4 adder that is able to perform subtraction and then a set of checks, the same that are in the \ref{comparator_advanced} are performed in order to generate the comparison outputs. We can perform the comparisons using this boolean equations, where $C$ is the carry-out and $Z$ is the zero check (all bits of the results are zeros):
\begin{align*}
	A > B &\rightarrow C \cdot \overline{Z}\\
	A \geq B &\rightarrow C\\
	A < B  &\rightarrow \overline{C}\\
	A \leq B &\rightarrow \overline{C} + Z\\
	A = B &\rightarrow Z\\
	A \neq B  &\rightarrow \overline{Z} 
\end{align*}

 In order to avoid to propagate six different signal, the outcomes of the comparisons are encoded into a signal \texttt{LGET} on two bits. The encoded value are the ones in the \ref{tab:lget} table.
 \begin{multicols}{2}
 	\begin{table}[H]
 		\begin{center}
 			\begin{tabular}{ c| c}
 				\texttt{LGET} & Case\\
 				\hline
 				01 & $A < B$ \\
 				00 & $A \leq B$ \\
 				11 & $A > B$ \\
 				10 & $A \geq B$
 				
 			\end{tabular}
 			\caption{LEQ encoding}
 			\label{tab:lget}
 		\end{center}
 	\end{table}
 	
 	\columnbreak
 	
 	\begin{lstlisting}[style=vhdl,caption={VHDL code for the encodig},label=lget_code]
 	LGET <= "01" when (a_l_b = '1') else
	 	"00" when (a_le_b = '1') else 
	 	"11" when (a_g_b = '1') else
	 	"10" when (a_ge_b = '1') else
	 	"00";
 	\end{lstlisting}
 \end{multicols}

The ordering of the comparison in the \texttt{when} statement is not casual nor follows the normal patterns but, the strictly lower comparison is done before the lower equals one, because, if the latter one is true it means that is also \texttt{A} lower than \texttt{B} but not vice-versa. Using this encoding, we can simply check the second bit in order to understand if \texttt{A} $\leq$ \texttt{B} or \texttt{A} $\geq$ \texttt{B}; instead, if we want to check only $<$ or $>$ comparisons we have to check also the first bit.

 

A further improvement has been done to the advanced comparator in order to manage comparison between both signed and unsigned numbers. The carry value works like this:
\begin{itemize}
  \item Carry = 1: if \(A > B\) in unsigned
  \item Carry \(=\) 0: if \(A \leq B\) in unsigned
\end{itemize}

The advanced comparator works with unsigned numbers only. So it simply needs to be adapted for cases in which signed comparison and unsigned comparison are different. They are shown in the \autoref{comparator_cases} highlighted in red. 
It is easy to notice that in the red lines A and B always have different sign. The logic must work when the UNSIG\_SIGN\_N bit is 0, that means the circuit is dealing with a signed number. In this case the carry bit must be complemented. Knowing this things, it's easy to derive the following logic:

\begin{verbatim}
  i_cout_masked <= Cout xor (not(UNSIG_SIGN_N) and (A(A'length-1) xor B(B'length-1)));
\end{verbatim}

\begin{table}[H]
  \centering
  \begin{tabular}{c|c|c|c|c}
      \textbf{A} & \textbf{B} & \textbf{Carry out} & \textbf{Signed comparison} & \textbf{Unsigned comparison} \\
      \hline
      2 & 3 & 0 & Less & Less \\
      4 & 3 & 1 & Greater & Greater \\
      3 & 3 & 1 & Equal & Equal \\
      \rowcolor{red!50}
      -3 & 3 & 1 & Less & Greater \\
      \rowcolor{red!50}
      -2 & 3 & 1 & Less & Greater \\
      \rowcolor{red!50}
      -5 & 3 & 1 & Greater & Greater \\
      \hline
      3 & 2 & 1 & Greater & Greater \\
      3 & 4 & 0 & Less & Less \\
      3 & 3 & 1 & Equal & Equal \\
      \rowcolor{red!50}
      3 & -3 & 0 & Greater & Less \\
      \rowcolor{red!50}
      3 & -2 & 0 & Greater & Less \\
      \rowcolor{red!50}
      3 & -5 & 0 & Greater & Less \\
      \hline
      \rowcolor{red!50}
      2 & -3 & 0 & Greater & Less \\
      \rowcolor{red!50}
      4 & -3 & 1 & Greater & Less \\
      \rowcolor{red!50}
      3 & -3 & 1 & Greater & Less \\
      -3 & -3 & 1 & Equal & Equal \\
      -2 & -3 & 1 & Greater & Greater \\
      -5 & -3 & 1 & Less & Less \\
      \hline
      \rowcolor{red!50}
      -3 & 2 & 1 & Less & Greater \\
      \rowcolor{red!50}
      -3 & 4 & 0 & Less & Greater \\
      \rowcolor{red!50}
      -3 & 3 & 1 & Less & Greater \\
      -3 & -3 & 0 & Equal & Equal \\
      -3 & -2 & 0 & Less & Less \\
      -3 & -5 & 0 & Greater & Greater \\
  \end{tabular}
  \caption{All cases of possible comparison}
  \label{comparator_cases}
\end{table}
So, we can summarize 
// INSERT HERE SCHEMA AND EXPLANATION


\section{Jump and Branch decision}
\section{Next Program Counter computation}